<template>
    <div id="Owner">
        <h1>Sessions</h1>
        <h2>Schedule New Session</h2>
        <div>
            <input type="time" placeholder="Start Time" v-model="newSessionStartTime" />
            <input type="time" placeholder="End Time" v-model="newSessionEndTime" />
            <input type="date" placeholder="Date" v-model="newSessionDate" />
            <input type="checkbox" v-model="newSessionRepeatsWeekly" /> Repeats Weekly
            <select v-model="newSessionClassType">
                <option v-for="classType in classTypes" :value="classType">{{ classType.name }}</option>
            </select>
            <input type="text" placeholder="Length" v-model="newSessionLength" />
            <input type="text" placeholder="Max Participants" v-model="newSessionMaxParticipants" />
            <button @click="createSession()" :disabled="isCreatebtnDisabled">Create Session</button>
            
        </div>
        <div>
            <h2>Current Sessions</h2>
            <table>
                <tbody id="sessions-tbody">
                    <tr>
                        <th>Time</th>
                        <th>ClassType</th>
                        <th>MaxParticipants</th>
                    </tr>
                    <tr v-for="s in sessions">
                        <td>{{ s.date }} - {{ s.startTime }} - {{ s.endTime }}</td>
                        <td>{{ s.classType.classType }} ({{ s.classType.isApproved ? 'Approved' : 'Not Approved' }})</td>
                        <td>{{ s.maxParticipants }}</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>
</template>

<script>
import axios, { Axios } from "axios";
import config from "../../config";
import vSelect from "vue-select";

const frontendUrl = `http://${config.dev.host}:${config.dev.port}`;
const backendUrl = `http://${config.dev.backendHost}:${config.dev.backendPort}`;

const client = axios.create({
    baseURL: backendUrl,
    headers: { 'Access-Control-Allow-Origin': frontendUrl }
})

export default {
    data() {
        return {
            sessions: [],
            classTypes: [],
            newSessionLength: null,
            newSessionStartTime: '',
            newSessionEndTime: '',
            newSessionDate: '',
            newSessionRepeatsWeekly: false,
            newSessionMaxParticipants: null,
            newSessionClassType: null,
        };
    },
    created: async function () {
        console.log('Fetching sessions...');
        try {
            const response = await client.get("/sessions");
            this.sessions = response.data;
            console.log('Fetched sessions:', this.sessions);
        }
        catch (e) {
            console.log('Error fetching sessions:', e);
        }

        console.log('Fetching class types...');

        try {
            const response = await client.get("/classTypes/true"); // Replace "/classTypes" with the actual endpoint
            this.classTypes = response.data;
            console.log('Fetched class types:', this.classTypes);
        }
        catch (e) {
            console.log('Error fetching class types:', e);
        }
    },
    
    methods: {
        createSessionDto () {
            console.log('Creating session DTO...');
            const date = new Date(this.newSessionDate);
            const formattedDate = date.toISOString().split('T')[0]; // Format to 'YYYY-MM-DD'

            const startTime = this.newSessionStartTime + ':00'; // Append seconds
            const endTime = this.newSessionEndTime + ':00'; // Append seconds

            const sessionDto = {
                id: 100, // Assuming this is generated by the backend
                length: parseInt(this.newSessionLength),
                startTime: startTime,
                endTime: endTime,
                date: formattedDate,
                isRepeating: this.newSessionRepeatsWeekly,
                maxParticipants: parseInt(this.newSessionMaxParticipants),
                classType: {
                    classType: this.newSessionClassType.name,
                    isApproved: true // Assuming all classes are approved by default
                },
                instructorId: 1 
            };

            console.log('Created session DTO:', sessionDto);
            return sessionDto;
        },
        
        createSession: async function () {
            console.log('Creating session...');
            const newSession = this.createSessionDto();
            try {
                const response = await client.post("/sessions", newSession);
                this.sessions.push(response.data);
                this.clearInputs();
                console.log('Created session:', response.data);
            }
            catch (e) {
                console.log('Error creating session:', e.message);
            }
        },
        clearInputs() {
            console.log('Clearing inputs...');
            this.newSessionLength = null;
            this.newSessionStartTime = null;
            this.newSessionEndTime = null;
            this.newSessionDate = null;
            this.newSessionRepeatsWeekly = false;
            this.newSessionMaxParticipants = null;
            console.log('Cleared inputs');
        }
    },
    computed: {
        isCreatebtnDisabled() {
            const disabled = !this.newSessionLength 
            || !this.newSessionStartTime 
            || !this.newSessionEndTime 
            || !this.newSessionDate 
            || !this.newSessionMaxParticipants
            || !this.newSessionClassType;
            console.log('Create button disabled:', disabled);
            return disabled;
        }
    }
}
</script>